<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
    <!-- <script type="text/javascript" src="./artists.json"></script> -->
    <script src="./bezier.js"></script>
    <script src="./animate.js"></script>
    <script src="./ui_elements.js"></script>
    <script src="./director.js"></script>
    <script src="./index.js"></script>

  </head>

  <body>
    <style>
      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
    </style>
    <script defer>
      const horizontalPadding = 50;
      const verticalPadding = 50;
      mainBackgroundColor = 0xffffff;
      const boxColor = 0x555555;

      //The App
      const app = new PIXI.Application({
        width: 1920,
        height: 1080,
        backgroundColor: 0xffffff,
      });

      // app.resizeTo = window;
      //Fix, or at least improve blurry text
      PIXI.settings.ROUND_PIXELS = true;

      //Add view to the document
      document.body.appendChild(app.view);

      // Some temporary data to start creating model
      class Artist {
        constructor(name, location, medium, description, headshotPath, galleryImages, url0) {
          this.name = name;
          this.location = location;
          this.medium = medium;
          this.description = description;
          this.headshotPath = headshotPath; // Add default later
          this.galleryImages = galleryImages; // Add default later
          this.url = url; //add default later
        }
      }
      const sampleArtist = {
        name: 'Isabella Rivera',
        location: 'New York City, USA',
        medium: 'Oil painting',
        description:
          "    Isabella Rivera's art is an exploration of the juxtaposition between the urban and the natural world. In the heart of New York City, she finds inspiration in the city's towering skyscrapers and bustling streets, which she blends seamlessly with the serene beauty of nature. \n    Her oil paintings aim to capture the essence of this harmony by using vivid colors and intricate details to depict the dynamic interplay between these two seemingly contrasting realms. Through her work, she hopes to remind viewers that even within the concrete jungle, there is a place for the organic and the tranquil.",
        headshotPath: './img/headshots/headshot.jpg',
        galleryImages: [
          './img/gallery/mountains.jpg',
          './img/gallery/prism.jpg',
          './img/gallery/wind.jpg',
          './img/gallery/dog.jpg',
          './img/gallery/trees.jpg',
          './img/gallery/abstract.jpg',
        ],
      };
      const mainScreen = new PIXI.Container();

      const artistCatalog = new PIXI.Container();

      const views = [];
      function buildMainScreen(name, description) {
        const exhibitName = new PIXI.Text(name);
        const exhibitDescription = new PIXI.Text(description);
        const navButton = new UI.Button(app.view.width, app.view.height, "View Featured Artists >>");
        navButton.x -= navButton.width;
        navButton.y -= navButton.height;
        navButton.onclick = () => {
          Director.showScene("catalog", { transition: Director.swipe, direction: "left", duration: 2000 });
        };
        mainScreen.addChild(exhibitName);
        mainScreen.addChild(exhibitDescription);
        mainScreen.addChild(navButton);
        exhibitDescription.y = exhibitName.height + exhibitName.y;
      }

      function buildArtistCatalog(artistPages) {
        const carouselMaskLeft = new PIXI.Graphics();
        const carouselMaskRight = new PIXI.Graphics();
        carouselMaskLeft.beginFill(mainBackgroundColor);
        carouselMaskLeft.drawRect(
          0,
          0,
          100,
          650
        );
        carouselMaskRight.beginFill(mainBackgroundColor);
        carouselMaskRight.drawRect(
          0,
          0,
          100,
          650
        );
        carouselMaskLeft.y = app.view.height / 2 - carouselMaskLeft.height / 2;
        carouselMaskRight.y = app.view.height / 2 - carouselMaskRight.height / 2;
        carouselMaskRight.x = app.view.width - carouselMaskRight.width;
        const catalog = new PIXI.Container();
        artistCatalog.addChild(catalog);
        let count = 0;
        artistPages.forEach(page => {
          Director.addScene(count, page); // Adding each page to the director
          const artist = new PIXI.Container();
          artist.viewIndex = count; // Giving the artist photo a reference to the page it's supposed to lead to
          const placeHolder = new PIXI.Graphics();
          const name = new PIXI.Text("Artist Name");
          placeHolder.beginFill(0x999999);
          placeHolder.drawRect(0, 0, 450, 650);
          artist.addChild(placeHolder);
          artist.addChild(name);
          catalog.addChild(artist);
          if (count > 0) {
            artist.x = catalog.children[count - 1].x + artist.width + 50;
          } else {
            artist.x = carouselMaskLeft.width;
          }
          count += 1;
        });
        artistCatalog.addChild(carouselMaskLeft);
        artistCatalog.addChild(carouselMaskRight);

        catalog.y = app.view.height / 2 - catalog.height / 2;

        catalog.interactive = true;
        catalog.dragging = false;
        catalog.on('pointerdown', (e) => {
          catalog.calculateBounds();
          catalog.offsetX = catalog.x - e.global.x;
          catalog.offsetY = catalog.y - e.global.y;
          catalog.dragging = true;
        });
        catalog.on('pointermove', (e) => {
          if (catalog.dragging) {
            catalog.x = e.global.x + catalog.offsetX;
            //Check constraints
            if (catalog.width > 0.75 * app.view.width) {
              if (catalog.x < -catalog.width + 0.75 * app.view.width) {
                //Right limit
                catalog.x = -catalog.width + 0.75 * app.view.width;
              } else if (catalog.x > 0.25 * app.view.width) {
                //Left limit
                catalog.x = 0.25 * app.view.width;
              }
            } else {
              catalog.x = horizontalPadding + 200;
            }
          }
        });

        catalog.on('pointerup', (e) => {
          catalog.dragging = false;
        });
        catalog.on('pointerupoutside', (e) => {
          catalog.dragging = false;
        });
        // console.log(catalog.children);
        catalog.children.forEach(artist => {
          artist.interactive = true;
          artist.on("pointerup", (e) => {

            Director.showScene(`${artist.viewIndex}`, { transition: Director.swipe, direction: "down", duration: 1000 });
          });
        });
      }
      // Create containers for the two main view components

      buildMainScreen("Sample Exhibit", "This is where I'd put a description, if I had one!");

      function buildArtistPage(artistData) {
        const artistProfile = new PIXI.Container();
        artistProfile.name = artistData.name;
        artistProfile.headshotPath = artistData.headshotPath;
        const imageGallery = new PIXI.Container();

        async function buildArtistProfile(artist) {
          PIXI.Assets.load(artist.headshotPath)
            .then(async () => {
              const texture = await PIXI.Assets.load(artist.headshotPath);
              const artistPhoto = await new PIXI.Sprite(texture);

              //Adding rectangles to crop photo to uniform dimensions of 650X450
              const leftCrop = new PIXI.Graphics();
              const rightCrop = new PIXI.Graphics();

              artistPhoto.height = 650;
              artistPhoto.width =
                (650 / artistPhoto.texture.baseTexture.height) *
                artistPhoto.width;
              artistPhoto.x = horizontalPadding;
              artistPhoto.y = verticalPadding;
              artistProfile.addChild(artistPhoto);
              artistProfile.addChild(leftCrop);
              artistProfile.addChild(rightCrop);
              leftCrop.beginFill(mainBackgroundColor);
              rightCrop.beginFill(mainBackgroundColor);
              leftCrop.drawRect(
                horizontalPadding,
                verticalPadding,
                Math.abs(artistPhoto.width - 450) / 2,
                650
              );
              rightCrop.drawRect(
                horizontalPadding +
                artistPhoto.width -
                Math.abs(artistPhoto.width - 450) / 2,
                verticalPadding,
                Math.abs(artistPhoto.width - 450) / 2,
                650
              );
              // leftCrop.x -= (artistPhoto.width - leftCrop.width);
            })
            .then(() => {
              const infoBox = new PIXI.Container();
              const infoBoxPadding = 50;
              const infoBoxElementSpacing = 10;
              const infoBoxBackground = new PIXI.Graphics();
              infoBoxBackground.beginFill(mainBackgroundColor);
              infoBoxBackground.drawRect(0, 0, 1300, 650);
              const artistName = new PIXI.Text(artist.name, {
                fontFamily: 'sans-serif',
                fontWeight: 'bold',
                fontSize: 32,
                fill: 0x000000,
              });
              const artistLocation = new PIXI.Text(artist.location, {
                fontFamily: 'sans-serif',
                fontSize: 26,
                fill: 0x000000,
              });
              const artistMedium = new PIXI.Text(artist.medium, {
                fontFamily: 'sans-serif',
                fontSize: 26,
                fill: 0x000000,
              });

              const artistQRCode = new PIXI.Graphics();
              artistQRCode.beginFill(0x000000);
              artistQRCode.drawRect(0, 0, 300, 300);

              const artistDescription = new PIXI.Text(artist.description, {
                fontFamily: 'sans-serif',
                lineHeight: 35,
                wordWrap: true,
                wordWrapWidth: (infoBoxBackground.width * 2) / 3 - infoBoxPadding,
                fontSize: 26,
                fill: 0x000000,
              });

              infoBox.addChild(infoBoxBackground);
              infoBox.addChild(artistName);
              infoBox.addChild(artistLocation);
              infoBox.addChild(artistMedium);
              infoBox.addChild(artistQRCode);
              infoBox.addChild(artistDescription);

              artistName.x = infoBoxPadding;
              artistName.y = infoBoxPadding;
              artistLocation.x = infoBoxPadding;
              artistLocation.y =
                artistName.y +
                artistName.height / 2 +
                artistLocation.height +
                infoBoxElementSpacing;
              artistMedium.x = infoBoxPadding;
              artistMedium.y =
                artistLocation.y + artistMedium.height + infoBoxElementSpacing;
              artistQRCode.x = infoBoxPadding;
              artistQRCode.y =
                artistMedium.y + artistMedium.height + 2 * infoBoxElementSpacing;
              artistDescription.x = infoBoxBackground.width / 3 - infoBoxPadding;
              artistDescription.y = infoBoxPadding;

              // Anchoring to the top right of the screen
              infoBox.x = app.view.width - infoBox.width - horizontalPadding;
              infoBox.y = verticalPadding;
              artistProfile.addChild(infoBox);
            });
        }

        async function buildGallery(images) {
          // const carouselMaskLeft = new PIXI.Graphics();
          // const carouselMaskRight = new PIXI.Graphics();
          // carouselMaskLeft.beginFill(mainBackgroundColor);
          // carouselMaskLeft.drawRect(
          //   0,
          //   app.view.height - 250 - verticalPadding,
          //   250,
          //   250
          // );
          // carouselMaskRight.beginFill(mainBackgroundColor);
          // carouselMaskRight.drawRect(
          //   app.view.width - 250,
          //   app.view.height - 250 - verticalPadding,
          //   250,
          //   250
          // );
          // // Placeholder to allocate space while the images load, since we can't just do things in a set order apparently.
          const imageGalleryPlaceholder = new PIXI.Graphics();
          imageGallery.addChild(imageGalleryPlaceholder);
          imageGalleryPlaceholder.beginFill(boxColor);
          imageGalleryPlaceholder.drawRect(0, 0, 150, 250);
          await PIXI.Assets.load(images)
            .then(() => {
              imageGallery.children.pop(0);
              // This way to make this work seems pretty cursed, but whatever.
              let count = 0;
              images.forEach(async (path) => {
                const texture = await PIXI.Assets.load(path);
                const sprite = await new PIXI.Sprite(texture);
                sprite.height = 250;
                sprite.width =
                  (250 / sprite.texture.baseTexture.height) * sprite.width;
                imageGallery.addChild(sprite);
                if (count != 0) {
                  sprite.x =
                    imageGallery.children[count - 1].x +
                    imageGallery.children[count - 1].width +
                    50;
                } else {
                  sprite.x = 0;
                }
                imageGallery.sortableChildren = true;
                sprite.interactive = true;
                sprite.enlarged = false;
                sprite.originalScaleX = sprite.scale.x;
                sprite.originalScaleY = sprite.scale.y;
                async function enlargeToggle(target) {
                  if (!target.enlarged) {
                    target.interactive = false;
                    target.originalX = target.x;
                    target.originalY = target.y;
                    target.zIndex = 1000;
                    await Animate.to(target, {
                      duration: 500,
                      scale: {
                        x: 1,
                        y: 1,
                      },

                    });
                    await Animate.to(target, {
                      duration: 500,
                      x: app.view.width / 2 - target.parent.x - target.width / 2,
                      y: app.view.height / 2 - target.parent.y - target.height / 2,
                    });


                    target.enlarged = true;
                    target.interactive = true;
                  } else {
                    target.zIndex = 0;
                    await Animate.to(target, {
                      scale: {
                        x: ((250 / sprite.texture.baseTexture.height) * sprite.texture.baseTexture.width) / sprite.width,
                        y: 250 / sprite.height
                      },
                      x: target.originalX,
                      y: target.originalY,
                      duration: 250
                    });
                    target.enlarged = false;
                  }
                }
                sprite.on("pointerdown", (e) => {
                  sprite.interactionTimeStamp = Date.now();

                });
                sprite.on("pointerup", (e) => {
                  console.log(Date.now() - sprite.interactionTimeStamp);
                  if (Date.now() - sprite.interactionTimeStamp < 150) { // Adding a minimum interval between pointer up and down to distinguish between dragging and tapping.
                    sprite.parent.children.forEach(child => {

                      if (child != sprite) {
                        //Toggling off interactivity of other images and gallery carousel thing so things don't get weird
                        child.interactive = !child.interactive;
                        sprite.parent.interactive = !sprite.parent.interactive;
                      }
                    });
                    enlargeToggle(sprite);
                  }


                });
                count += 1;
              });
            })
            .then(() => {
              imageGallery.children.forEach(child => child.enlarged = false);
              artistProfile.addChild(imageGallery);
              // artistProfile.addChild(carouselMaskLeft);
              // artistProfile.addChild(carouselMaskRight);
            });
        }
        buildGallery(artistData.galleryImages);
        buildArtistProfile(
          artistData
        );

        // Anchoring to the bottom left of the screen with extra padding to allow for a back button
        imageGallery.x = horizontalPadding + 200;
        imageGallery.y = app.view.height - imageGallery.height - verticalPadding;

        // Making the gallery click+draggable horizontally
        imageGallery.interactive = true;
        imageGallery.dragging = false;
        imageGallery.on('pointerdown', (e) => {
          imageGallery.calculateBounds();
          imageGallery.offsetX = imageGallery.x - e.global.x;
          imageGallery.offsetY = imageGallery.y - e.global.y;
          imageGallery.dragging = true;

        });
        imageGallery.on('pointermove', (e) => {
          if (imageGallery.dragging) {
            imageGallery.x = e.global.x + imageGallery.offsetX;
            //Check constraints
            if (imageGallery.width > 0.75 * app.view.width) {
              if (imageGallery.x < -imageGallery.width + 0.75 * app.view.width) {
                //Right limit
                imageGallery.x = -imageGallery.width + 0.75 * app.view.width;
              } else if (imageGallery.x > 0.25 * app.view.width) {
                //Left limit
                imageGallery.x = 0.25 * app.view.width;
              }
            } else {
              imageGallery.x = horizontalPadding + 200;
            }
          }
        });

        imageGallery.on('pointerup', (e) => {

          imageGallery.dragging = false;

        });
        imageGallery.on('pointerupoutside', (e) => {
          imageGallery.dragging = false;
        });
        views.push(artistProfile);
      }
      buildArtistPage(sampleArtist);
      buildArtistPage(sampleArtist);
      buildArtistPage(sampleArtist);
      buildArtistPage(sampleArtist);
      buildArtistPage(sampleArtist);
      buildArtistPage(sampleArtist);
      //This should probably be done through the director later.
      buildArtistCatalog(views);
      // app.stage.addChild(artistCatalog)
      Director.addScene("main", mainScreen);
      Director.addScene("catalog", artistCatalog);
      Director.showScene("main", { transition: Director.fade, duration: 2000 })
    </script>
  </body>

</html>