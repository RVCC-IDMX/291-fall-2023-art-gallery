<!DOCTYPE html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
  <!-- <script type="text/javascript" src="./artists.json"></script> -->
  <script src="./data.js"></script>
  <script src="./bezier.js"></script>
  <script src="./animate.js"></script>
  <script src="./ui_elements.js"></script>
  <script src="./director.js"></script>
  <script src="./index.js"></script>

</head>

<body>
  <style>
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
  </style>
  <script defer>

    const mainBackgroundColor = 0xffffff;
    const boxColor = 0x555555;
    const buttonParams = {
      backgroundColor: 0x000000,
      textStyle: {
        fontFamily: 'Arial',
        fontSize: 20,
        fill: 0xFFFFFF
      }
    };

    //The App
    const app = new PIXI.Application({
      width: 1920,
      height: 1080,
      backgroundColor: 0xffffff,
      /*resolution:2,
      autoDensity:true*/
    });
    //Fix, or at least improve blurry text
    PIXI.settings.ROUND_PIXELS = true;

    //Add view to the document
    document.body.appendChild(app.view);

    // An array to store a varying number of artist pages
    const views = [];

    // Alex's Main/Start Screen
    function buildMainScreen(exhibit) {
      const container = new PIXI.Container();
      //Text
      // Create "Exhibit Name" text
      const exhibitName = new PIXI.Text(exhibit.title || "title", {
        fontFamily: 'Arial',
        fontSize: 48,
        fill: 0x000000, // Black color
      });
      exhibitName.position.set(150, 75);
      // Create "Exhibit background / Intro Text" text
      const introText = new PIXI.Text(exhibit.description || "description", {
        fontFamily: 'Arial',
        fontSize: 24,
        wordWrap: true,
        wordWrapWidth: 300,

        fill: 0x000000, // Black color
      });
      introText.position.set(0, 0);

      // Create "IMAGE" text
      const imageText = new PIXI.Text('IMAGE', {
        fontFamily: 'Arial',
        fontSize: 24,
        fill: 0x000000, // Black color
      });
      imageText.position.set(0, 0);
      // container.addChild(imageText);



      // Rectangles

      // Create first rectangle
      const rect1 = new PIXI.Graphics();
      rect1.beginFill(0xC0C0C0); // Lighter grey color
      rect1.lineStyle(3, 0x000000); // Black outline with 3px width
      rect1.drawRect(0, 0, 500, 615);
      rect1.x = 150;
      rect1.y = 175;
      rect1.endFill();
      rect1.addChild(introText);
      // introText.wordWrapWidth = introText.parent.width - 30;
      introText.style.wordWrapWidth = introText.parent.width - 20;
      introText.x = introText.parent.width / 2 - introText.width / 2;
      introText.y = 20;

      const rect2 = new PIXI.Graphics();
      rect2.beginFill(0xC0C0C0); // Lighter grey color
      rect2.lineStyle(4, 0x000000); // Black outline with 3px width
      rect2.drawRect(0, 0, 460, 690);
      rect2.x = 775;
      rect2.y = 102;
      rect2.endFill();

      // Create "window" rectangle
      const windowRect = new PIXI.Graphics();
      windowRect.beginFill(0xFFFFFF); // Light grey color
      windowRect.lineStyle(7.5, 0x000000); // Black outline with 3px width
      windowRect.drawRect(0, 0, 1400, 850);
      windowRect.endFill();
      windowRect.addChild(rect1);
      windowRect.addChild(rect2);
      windowRect.addChild(exhibitName);
      windowRect.x = 100;
      windowRect.y = 100;
      container.addChild(windowRect);
      windowRect.addChild(rect1);
      windowRect.addChild(rect2);

      let placeholder = PIXI.Sprite.from("img/placeholder.jpg");
      windowRect.addChild(placeholder);
      placeholder.scale.set(0.12);
      placeholder.x = 775;
      placeholder.y = 105;


      // Button

      // Create "To Artist Catalogue" button

      const buttonText = new PIXI.Text('To Artist Catalogue >>>', {
        fontFamily: 'Arial',
        fontSize: 24,
        fill: 0xFFFFFF,
      });

      const button = new PIXI.Graphics();
      button.beginFill(0x000000); // Black color
      button.drawRoundedRect(0, 0, 350, 70, 10);
      button.x = 600;
      button.y = 980;
      button.endFill();
      button.addChild(buttonText);
      // buttonText.x = parent.width / 2 - buttonText.width / 2;
      buttonText.x = 50;
      buttonText.y = 20;

      container.addChild(button);



      // Add hover effect to the button
      button.interactive = true;
      button.buttonMode = true;
      button.alpha = 1;

      button.on('pointerover', () => {
        button.alpha = 0.8; // Change opacity to 80% on hover
      });

      button.on('pointerout', () => {
        button.alpha = 1; // Restore opacity on mouse out
      });

      // Add navigation function to button
      button.on('pointertap', () => {
        Director.showScene("catalog", { transition: Director.swipe, direction: "left", duration: 750 });
      });
      return container;
    }

    // Sikholiwe's artist catalog
    function buildArtistCatalog(artistPages) {

      // The completed page to return
      const page = new PIXI.Container();
      // Container for grid layout
      const container = new PIXI.Container();


      // Calculate grid positions
      const gridSize = 4;
      const padding = 40;
      const imageSize = (app.screen.width - (padding * (gridSize + 2))) / gridSize;
      // const imageSize = 250

      for (let i = 0; i < artistPages.length; i++) {
        // Made some edits here so the grid can infinitely repeat
        const row = Math.floor((i % (2 * gridSize)) / gridSize);
        const col = i % gridSize;
        const offset = (app.view.width - padding * 2) * Math.floor(i / (gridSize * 2));
        // Create a container for each item
        const itemContainer = new PIXI.Container();
        itemContainer.viewIndex = i;

        // Create border
        const border = new PIXI.Graphics();
        border.lineStyle(5, 0x000000, 1);
        border.drawRect(0, 0, imageSize / 2, imageSize / 2 + 30); // Adjust the border size to include the name
        itemContainer.addChild(border);

        // Create image sprite
        const image = PIXI.Sprite.from(artistPages[i].headshotPath);
        const originalHeight = image.height;
        const originalWidth = image.width;
        image.width = imageSize / 2 - 5; // Adjust the scale factor and border size
        image.height = imageSize / 2 - 30; // Adjust the height to fit the name
        // image.height = imageSize;
        // image.width = originalWidth * imageSize/originalHeight
        image.position.set(2, 2); // Adjust position to fit within the border
        itemContainer.addChild(image);

        // Create name caption text
        const nameCaption = new PIXI.Text(artistPages[i].name, {
          fill: "black",
          fontSize: 20,
          fontWeight: "bold",
          align: "left",
        });

        itemContainer.addChild(nameCaption);
        nameCaption.position.set(nameCaption.parent.width / 2 - nameCaption.width / 2, imageSize / 2 - 20);

        // Position the container in the grid

        if (row < 1) {
          // Top row
          itemContainer.position.set(padding + col * (imageSize + padding) + offset, app.view.height * .33 - itemContainer.height / 2);
        } else {
          // Bottom row
          itemContainer.position.set(padding + col * (imageSize + padding) + offset, app.view.height * .66 - itemContainer.height / 2); // Adjust position to include the name
        }

        // Add touch events to the entire container
        itemContainer.interactive = true;
        // // 1. Event listener for name click
        // itemContainer.on('pointerdown', () => {
        //   goToPage(artistPages[i].name);
        // });

        // 2. Event listeners for left and right arrows
        if (artistPages[i].name === "Artists names") {
          leftArrow.on('pointerdown', () => {
            console.log("Left arrow clicked!");
            // Implement left arrow logic here
          });

          rightArrow.on('pointerdown', () => {
            console.log("Right arrow clicked!");
            // Implement right arrow logic here
          });

          // 3. Event listener for "Back to main screen" click
          backText.on('pointerdown', () => {
            goToPage("Main Screen");
          });
        }

        container.addChild(itemContainer);
      }

      const backgroundBox = new PIXI.Graphics();
      backgroundBox.beginFill(mainBackgroundColor);
      backgroundBox.drawRect(0, 0, container.width, container.height);
      backgroundBox.x = padding;
      backgroundBox.y = .5 * backgroundBox.height - padding * 2 + 10;
      container.addChildAt(backgroundBox, 0);
      page.addChild(container);

      const toMainScreenButton = new UI.Button(0, 0, "<< Welcome", buttonParams);
      toMainScreenButton.on("pointertap", () => Director.showScene("mainscreen", { transition: Director.swipe, direction: "right", duration: 1000 }));
      toMainScreenButton.y = app.view.height - padding - toMainScreenButton.height;
      toMainScreenButton.x = padding;
      page.addChild(toMainScreenButton);

      container.interactive = true;
      container.dragging = false;
      container.on('pointerdown', (e) => {
        container.calculateBounds();
        container.offsetX = container.x - e.global.x;
        container.offsetY = container.y - e.global.y;
        container.dragging = true;
      });
      container.on('pointermove', (e) => {
        if (container.dragging) {
          container.x = e.global.x + container.offsetX;
          //Check constraints
          if (container.width > 0.75 * app.view.width) {
            if (container.x < -container.width + 0.75 * app.view.width) {
              //Right limit
              container.x = -container.width + 0.75 * app.view.width;
            } else if (container.x > 0.25 * app.view.width) {
              //Left limit
              container.x = 0.25 * app.view.width;
            }
          } else {
            container.x = horizontalPadding + 200;
          }
        }
      });

      container.on('pointerup', (e) => {
        container.dragging = false;
      });
      container.on('pointerupoutside', (e) => {
        container.dragging = false;
      });
      container.children.forEach(artist => {
        artist.interactive = true;
        artist.interactionTimeStamp = Date.now();
        artist.on("pointerdown", (e) => {
          artist.interactionTimeStamp = Date.now();
        });
        artist.on("pointerup", async (e) => {
          if (Date.now() - artist.interactionTimeStamp <= 150) {
            await Director.showScene(`${artist.viewIndex}`, { transition: Director.swipe, direction: "down", duration: 1000 });
            // Reset position of catalog after navigating away. Animating in case catalog is still visible during transition for some reason. 
            Animate.to(container, {
              duration: 500,
              x: 0
            });
          }
        });
      });
      //      Draw arrows and text in the middle
      // const middleText = new PIXI.Text("Artists names", {
      //   fill: "black",
      //   fontSize: 24,
      //   fontWeight: "bold",
      //   align: "center",
      // });

      // middleText.position.set(app.screen.width / 2 - middleText.width / 1, app.screen.height / 2.8 - middleText.height / 20);
      // page.addChild(middleText);
      // app.stage.addChild(middleText);
      return page;
    }

    function buildArtistPage(artistData) {
      const horizontalPadding = 50;
      const verticalPadding = 50;
      const artistProfile = new PIXI.Container();
      artistProfile.name = artistData.name;
      artistProfile.headshotPath = artistData.headshotPath;
      const imageGallery = new PIXI.Container();
      const toCatalogButton = new UI.Button(0, 0, "<< Artist Catalog", buttonParams);
      toCatalogButton.on("pointertap", () => Director.showScene("catalog", { transition: Director.swipe, direction: "up", duration: 1000 }));
      toCatalogButton.y = app.view.height - toCatalogButton.height;
      toCatalogButton.x = horizontalPadding;
      artistProfile.addChild(toCatalogButton);

      async function buildArtistProfile(artist) {
        PIXI.Assets.load(artist.headshotPath)
          .then(async () => {
            const texture = await PIXI.Assets.load(artist.headshotPath);
            const artistPhoto = await new PIXI.Sprite(texture);

            //Adding rectangles to crop photo to uniform dimensions of 650X450
            const leftCrop = new PIXI.Graphics();
            const rightCrop = new PIXI.Graphics();

            artistPhoto.height = 650;
            artistPhoto.width =
              (650 / artistPhoto.texture.baseTexture.height) *
              artistPhoto.width;
            artistPhoto.x = horizontalPadding;
            artistPhoto.y = verticalPadding;
            artistProfile.addChild(artistPhoto);
            artistProfile.addChild(leftCrop);
            artistProfile.addChild(rightCrop);
            leftCrop.beginFill(mainBackgroundColor);
            rightCrop.beginFill(mainBackgroundColor);
            leftCrop.drawRect(
              horizontalPadding,
              verticalPadding,
              Math.abs(artistPhoto.width - 450) / 2,
              650
            );
            rightCrop.drawRect(
              horizontalPadding +
              artistPhoto.width -
              Math.abs(artistPhoto.width - 450) / 2,
              verticalPadding,
              Math.abs(artistPhoto.width - 450) / 2,
              650
            );
            // leftCrop.x -= (artistPhoto.width - leftCrop.width);
          })
          .then(() => {
            const infoBox = new PIXI.Container();
            const infoBoxPadding = 50;
            const infoBoxElementSpacing = 10;
            const infoBoxBackground = new PIXI.Graphics();
            infoBoxBackground.beginFill(mainBackgroundColor);
            infoBoxBackground.drawRect(0, 0, 1300, 650);
            const artistName = new PIXI.Text(artist.name, {
              fontFamily: 'sans-serif',
              fontWeight: 'bold',
              fontSize: 32,
              fill: 0x000000,
            });
            const artistLocation = new PIXI.Text(artist.location, {
              fontFamily: 'sans-serif',
              fontSize: 26,
              fill: 0x000000,
            });
            const artistMedium = new PIXI.Text(artist.medium, {
              fontFamily: 'sans-serif',
              fontSize: 26,
              fill: 0x000000,
            });

            const artistQRCode = new PIXI.Graphics();
            artistQRCode.beginFill(0x000000);
            artistQRCode.drawRect(0, 0, 300, 300);

            const artistDescription = new PIXI.Text(artist.description, {
              fontFamily: 'sans-serif',
              lineHeight: 35,
              wordWrap: true,
              wordWrapWidth: (infoBoxBackground.width * 2) / 3 - infoBoxPadding,
              fontSize: 26,
              fill: 0x000000,
            });

            infoBox.addChild(infoBoxBackground);
            infoBox.addChild(artistName);
            infoBox.addChild(artistLocation);
            infoBox.addChild(artistMedium);
            infoBox.addChild(artistQRCode);
            infoBox.addChild(artistDescription);

            artistName.x = infoBoxPadding;
            artistName.y = infoBoxPadding;
            artistLocation.x = infoBoxPadding;
            artistLocation.y =
              artistName.y +
              artistName.height / 2 +
              artistLocation.height +
              infoBoxElementSpacing;
            artistMedium.x = infoBoxPadding;
            artistMedium.y =
              artistLocation.y + artistMedium.height + infoBoxElementSpacing;
            artistQRCode.x = infoBoxPadding;
            artistQRCode.y =
              artistMedium.y + artistMedium.height + 2 * infoBoxElementSpacing;
            artistDescription.x = infoBoxBackground.width / 3 - infoBoxPadding;
            artistDescription.y = infoBoxPadding;

            // Anchoring to the top right of the screen
            infoBox.x = app.view.width - infoBox.width - horizontalPadding;
            infoBox.y = verticalPadding;
            artistProfile.addChild(infoBox);
          });
      }

      async function buildGallery(images) {
        // // Placeholder to allocate space while the images load, since we can't just do things in a set order apparently.
        const imageGalleryPlaceholder = new PIXI.Graphics();
        imageGallery.addChild(imageGalleryPlaceholder);
        imageGalleryPlaceholder.beginFill(boxColor);
        imageGalleryPlaceholder.drawRect(0, 0, 150, 250);
        await PIXI.Assets.load(images)
          .then(() => {
            imageGallery.children.pop(0);
            // This way to make this work seems pretty cursed, but whatever.
            let count = 0;
            images.forEach(async (path) => {
              const texture = await PIXI.Assets.load(path);
              const sprite = await new PIXI.Sprite(texture);
              sprite.height = 250;
              sprite.width =
                (250 / sprite.texture.baseTexture.height) * sprite.width;
              imageGallery.addChild(sprite);
              if (count != 0) {
                sprite.x =
                  imageGallery.children[count - 1].x +
                  imageGallery.children[count - 1].width +
                  50;
              } else {
                sprite.x = 0;
              }
              imageGallery.sortableChildren = true;
              sprite.interactive = true;
              sprite.enlarged = false;
              sprite.originalScaleX = sprite.scale.x;
              sprite.originalScaleY = sprite.scale.y;
              async function enlargeToggle(target) {
                if (!target.enlarged) {
                  target.interactive = false;
                  target.originalX = target.x;
                  target.originalY = target.y;
                  target.zIndex = 1000;
                  await Animate.to(target, {
                    duration: 500,
                    scale: {
                      x: 1,
                      y: 1,
                    }

                  });
                  await Animate.to(target, {
                    duration: 500,
                    x: app.view.width / 2 - target.parent.x - target.width / 2,
                    y: app.view.height / 2 - target.parent.y - target.height / 2,
                  });


                  target.enlarged = true;
                  target.interactive = true;
                } else {
                  // Set the catalog navigation button to non-interactive
                  toCatalogButton.interactive = true;
                  target.zIndex = 0;
                  await Animate.to(target, {
                    scale: {
                      x: ((250 / sprite.texture.baseTexture.height) * sprite.texture.baseTexture.width) / sprite.width,
                      y: 250 / sprite.height
                    },
                    x: target.originalX,
                    y: target.originalY,
                    duration: 250
                  });
                  target.enlarged = false;
                }
              }

              // Separating the pointer event into up and down and adding a timer
              // To distinguish between tapping an image and dragging the gallery
              sprite.on("pointerdown", (e) => {
                sprite.interactionTimeStamp = Date.now();
              });
              sprite.on("pointerup", (e) => {
                console.log(Date.now() - sprite.interactionTimeStamp);
                if (Date.now() - sprite.interactionTimeStamp < 150) { // Adding a minimum interval between pointer up and down to distinguish between dragging and tapping.
                  sprite.parent.children.forEach(child => {

                    if (child != sprite) {
                      //Toggling off interactivity of other images and gallery carousel thing so things don't get weird
                      child.interactive = !child.interactive;
                      toCatalogButton.interactive = false;
                      sprite.parent.interactive = !sprite.parent.interactive;
                    }
                  });
                  enlargeToggle(sprite);
                }


              });
              count += 1;
            });
          })
          .then(() => {
            imageGallery.children.forEach(child => child.enlarged = false);
            artistProfile.addChild(imageGallery);
            // artistProfile.addChild(carouselMaskLeft);
            // artistProfile.addChild(carouselMaskRight);
          });
      }
      buildGallery(artistData.galleryImages);
      buildArtistProfile(
        artistData
      );

      // Anchoring to the bottom left of the screen with extra padding to allow for a back button
      imageGallery.x = horizontalPadding + 200;
      imageGallery.y = app.view.height - imageGallery.height - 2 * verticalPadding;

      // Making the gallery click+draggable horizontally
      imageGallery.interactive = true;
      imageGallery.dragging = false;
      imageGallery.on('pointerdown', (e) => {
        imageGallery.calculateBounds();
        imageGallery.offsetX = imageGallery.x - e.global.x;
        imageGallery.offsetY = imageGallery.y - e.global.y;
        imageGallery.dragging = true;

      });
      imageGallery.on('pointermove', (e) => {
        if (imageGallery.dragging) {
          imageGallery.x = e.global.x + imageGallery.offsetX;
          //Check constraints
          if (imageGallery.width > 0.75 * app.view.width) {
            if (imageGallery.x < -imageGallery.width + 0.75 * app.view.width) {
              //Right limit
              imageGallery.x = -imageGallery.width + 0.75 * app.view.width;
            } else if (imageGallery.x > 0.25 * app.view.width) {
              //Left limit
              imageGallery.x = 0.25 * app.view.width;
            }
          } else {
            imageGallery.x = horizontalPadding + 200;
          }
        }
      });

      imageGallery.on('pointerup', (e) => {

        imageGallery.dragging = false;

      });
      imageGallery.on('pointerupoutside', (e) => {
        imageGallery.dragging = false;
      });

      // Add a nav button for returning to the catalog screen


      views.push(artistProfile);

      // Add an index to the profile for use in loading via the Director
      artistProfile.viewIndex = views.length - 1;
      Director.addScene(artistProfile.viewIndex, artistProfile);
    }

    // // Building the main screen
    // buildMainScreen("Sample Exhibit", "This is where I'd put a description, if I had one!");

    // Building some artist pages and adding them to the director
    artistData.forEach(artist => buildArtistPage(artist));

    // Creating an artist catalog with a link to each artist profile
    const artistCatalog = buildArtistCatalog(views);

    // Creating the main screen
    const mainScreen = buildMainScreen(exhibitData);

    Director.addScene("catalog", artistCatalog);
    Director.addScene("mainscreen", mainScreen);
    Director.showScene("mainscreen", { transition: Director.fade, duration: 1000 })
  </script>
</body>

</html>